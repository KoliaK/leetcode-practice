<-- 1. Common Data Structures -->
These are divided into linear (sequential) and non-linear (hierarchical/connected) structures.

# Linear Structures
Arrays: A collection of elements stored in contiguous memory locations. They are great for fast access (reading data) if you know the index, but slow for inserting or deleting items in the middle.

Linked Lists: Elements are stored in nodes, where each node points to the next one. They are better for insertion/deletion but slower for accessing specific elements because you have to traverse the chain.

Stacks: A "Last-In, First-Out" (LIFO) structure. Think of a stack of plates; you add to the top and remove from the top. Used heavily in undo mechanisms and function call management.

Queues: A "First-In, First-Out" (FIFO) structure. Think of a line at a store; the first person in line is the first served.

# Non-Linear Structures
Trees: A hierarchical structure with a "root" node and "children."

Binary Search Tree (BST): A tree where the left child is smaller than the parent and the right child is larger. This makes searching very fast.

Heaps: A special tree used to quickly find the maximum or minimum element (often used in priority queues).

Graphs: A collection of nodes (vertices) connected by edges. They are used to model networks like social media connections, maps (GPS), or the internet itself.

Hash Tables (Hash Maps): One of the most important structures. They store data in key-value pairs. They use a "hash function" to compute an index into an array of buckets or slots, allowing for incredibly fast data retrieval.

<-- 2. Common Algorithms -->
Algorithms are generally categorized by the problem they solve or the strategy they use.

Sorting Algorithms
Sorting is often used as a preliminary step to make other algorithms faster.

Merge Sort: A "divide and conquer" algorithm that splits a list in half, sorts the halves, and merges them back together. It is very stable and reliable.

Quick Sort: Picks a "pivot" element and partitions the array into elements smaller and larger than the pivot. It is usually faster than Merge Sort in practice but can be slower in worst-case scenarios.

Searching Algorithms
Linear Search: Checks every element one by one. Simple but slow for large datasets.

Binary Search: Used on sorted lists. It repeatedly divides the search interval in half. If the value you are looking for is less than the item in the middle, it narrows the interval to the lower half (and vice versa).

Graph Traversals
Breadth-First Search (BFS): Explores a graph layer by layer (closest neighbors first). Great for finding the shortest path in an unweighted graph.

Depth-First Search (DFS): Explores as far as possible along each branch before backtracking. Useful for puzzles, mazes, and topological sorting.

Key Paradigms
Recursion: A function that calls itself to solve smaller instances of the same problem (e.g., calculating Fibonacci numbers).

Dynamic Programming (DP): A method for solving complex problems by breaking them down into simpler subproblems and storing their solutions (memoization) so you don't have to re-calculate them (e.g., the Knapsack problem).

<-- Big O Notation -->
1. Excellent / Fast
• O(1) — Constant Time: The execution time remains the same regardless of how much data you have.

  • Example: Accessing a specific index in an array.

• O(log n) — Logarithmic Time: The execution time grows very slowly.

  • Example: Binary Search.

2. Fair / Moderate
• O(n) — Linear Time: The execution time grows directly in proportion to the input size.

  • Example: A simple for loop (Linear Search).

• O(n log n) — Linearithmic Time: Slightly slower than linear time, but much faster than quadratic.

  • Example: Merge Sort, Quick Sort.

3. Poor / Slow
• O(n^2) — Quadratic Time: The execution time grows proportional to the square of the input.

  • Example: Nested loops.

• O(2^n) — Exponential Time: The execution time doubles with each additional element.

  • Example: Recursive algorithms without memoization.

• O(n!) — Factorial Time: The execution time grows astronomically fast.

  • Example: Brute force solution to the Traveling Salesman Problem.

Notation,Name,Complexity Class,Input n=10,Input n=100
O(1),Constant,Excellent,1 step,1 step
O(logn),Logarithmic,Excellent,~3 steps,~7 steps
O(n),Linear,Fair,10 steps,100 steps
O(nlogn),Linearithmic,Good,~33 steps,~664 steps
O(n2),Quadratic,Bad,100 steps,"10,000 steps"
O(2n),Exponential,Horrible,"1,024 steps",1.26×1030 steps